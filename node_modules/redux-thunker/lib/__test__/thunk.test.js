'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _index = require('../index');

/**
 * mock functions
 */
var getStateMock = function getStateMock() {
  return {
    user: {
      name: 'Emma Watson',
      occupation: 'Actress',
      status: 'Beautiful'
    }
  };
};

var dispatchMock = function dispatchMock() {};

var defaultArguments = {
  getState: getStateMock
};

describe('Thunker Middleware', function () {
  var nextHandler = (0, _index.thunk)({
    dispatch: dispatchMock,
    getState: getStateMock
  });

  test('Must return a function to handle action', function () {
    var actionHandler = nextHandler();
    expect(typeof actionHandler === 'undefined' ? 'undefined' : _typeof(actionHandler)).toBe('function');
  });

  test('run action with dispatch and getState', function (done) {
    var actionHandler = nextHandler();

    actionHandler(function (_ref) {
      var dispatch = _ref.dispatch,
          getState = _ref.getState;

      expect(dispatch).toEqual(dispatchMock);
      expect(getState).toEqual(getStateMock);
      done();
    });
  });

  test('pass to next if not action', function (done) {
    var actionTest = {
      type: 'action'
    };
    var actionHandler = nextHandler(function (action) {
      expect(action).toEqual(actionTest);
      done();
    });

    actionHandler(actionTest);
  });

  var nextHandlerCompatible = _index.thunk.extraArguments({
    config: {
      reduxThunkCompatible: true
    }
  })({
    dispatch: dispatchMock,
    getState: getStateMock
  });

  describe('Compatible thunk', function () {
    test('run action with dispatch and getState', function (done) {
      var actionHandler = nextHandlerCompatible();

      actionHandler(function (dispatch, getState) {
        expect(dispatch).toEqual(dispatchMock);
        expect(getState).toEqual(getStateMock);
        done();
      });
    });
  });

  var nextHandlerCompatibleNotContinuous = _index.thunk.extraArguments({
    config: {
      continuous: true
    }
  })({
    dispatch: dispatchMock,
    getState: getStateMock
  });

  describe('Continuos next', function () {
    test('run action with dispatch and getState, has them', function (done) {
      var actionTestResult = {
        type: 'hello'
      };

      var actionTest = function actionTest(_ref2) {
        var getState = _ref2.getState;

        expect(getState).toEqual(getStateMock);
        return actionTestResult;
      };

      var actionHandler = nextHandlerCompatibleNotContinuous(function (action) {
        expect(action).toEqual(actionTestResult);
        done();
      });
      actionHandler(actionTest);
    });
  });
});

describe('Enhancing Arguments', function () {
  test('No arguments to be enhanced, should return null', function () {
    // first param for enhanceArguments
    var suit = [null, {}, undefined];

    suit.forEach(function (arg) {
      var enhancedArgs = (0, _index.enhanceArguments)(arg, defaultArguments);
      expect(enhancedArgs).toBeNull();
    });
  });

  test('To be enhanced is not a function, error', function () {
    // first param for enhanceArguments
    var suit = [{
      notAFunction: {
        sadly: 'an object'
      }
    }];

    suit.forEach(function (arg) {
      expect(function () {
        return (0, _index.enhanceArguments)(arg, defaultArguments);
      }).toThrowError();
    });
  });
  test('Arguments to be enhanced', function () {
    // first param for enhanceArguments
    var input = {
      f: function f(_ref3) {
        var getState = _ref3.getState;
        return function () {
          return {
            type: 'test',
            payload: getState()
          };
        };
      }
    };
    var enhanced = (0, _index.enhanceArguments)(input, defaultArguments);
    expect(enhanced).toHaveProperty('f');
    expect(_typeof(enhanced.f)).toBe('function');
  });
});